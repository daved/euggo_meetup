###
Common Criticisms
Sometimes weaknesses, sometimes strengths.
4 Feb 2016
Tags: introduction, criticisms



###
Daved
disjuncter@gmail.com
https://github.com/daved
https://github.com/codemodus



###
* "Go lacks generics."

#--
* Generics For Today

- Approve implmentation {x}. (harms build time and lang/lang maint)
- Use a library. (harms app performance and orthogonality)
- Accept some duplication. (harms dev and maint time)
- Use a generator. (adds build step and harms dev time)

#--
* Generics For Tomorrow

"Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do.

Generics are convenient but they come at a cost in complexity in the type system and run-time. We haven't yet found a design that gives value proportionate to the complexity, although we continue to think about it."

.link https://golang.org/doc/faq#generics Golang.org/doc/faq#generics



###
* "Why is Go an imperative language?"

#--
* Purity Of Pragmatism

Posted by Ian Lance Taylor (Member of the Go Team at Google):

"A typical Google program is a web server that interacts with a database.  A typical program written in a functional language is a mathematical computation in which the outputs depend only on the inputs.  Those are completely different cases.

You can of course write a web server that uses a database in a functional language.  But I believe that few people starting from scratch, without any bias about functional languages, would decide that a functional language was the best choice for that problem.

Therefore, Go was not designed as a functional language."

.link https://www.quora.com/Why-wasnt-Go-written-as-a-functional-language/answer/Ian-Lance-Taylor?srid=pRa&share=1 Quora.com/Why-wasnt-Go-written-as-a-functional-language



###
* "Isn't nil just null?"
#* , "The type system is terrible.", etc.

#--
* nil can bite. Errors help muzzle it.

- Functions often return multiple values.
- An error returned with another value is much like a result type in FP. 

.code bad_nil/main.go /START1 OMIT/,/END1 OMIT/

A possibly nil `f` isn't the problem here.

#--
* Check errors.

.code bad_nil/main.go /START2 OMIT/,/END2 OMIT/

- Checking errors is roughly as verbose as result type handling.
- It is rare for the benefits of pattern matching to be worthwhile in this usage.
- Dynamic langs usually complicate control flow or ignore error handling.



###
* "I don't like Go's error handling."

#--
* Errors are not exceptional

- Errors are values that usually affect control flow.
- Failures should be an integral concern.
- Ignoring potentialities is bad design.

#--
* Errors should be checked; Nay, they must be checked.

.play errors/main.go /START OMIT/,/END OMIT/

#--
* For a more thorough understanding of errors...

From 2011 (technical and introductory):

.link https://blog.golang.org/error-handling-and-go blog.Golang.org/error-handling-and-go

From 2015 (philosophical and ancillary):

.link https://blog.golang.org/errors-are-values blog.Golang.org/errors-are-values



###
* Field/Method Export Leaks

#--
* 

.code bad_type/p1/p1.go

.play bad_type/main.go /START OMIT/,/END OMIT/

- This can happen, but is normally not a problem.
- Use an intermediate type if needed.

#--
* 

.iframe http://play.golang.org/p/DfH2CaUqGKu 760 980



###
* "Go has no dependency management."

#--
* Solutions From The Community

- Libs are often simple and stable enough to manage manually.
- First direct solution to appear was gvm.
- Then godep and many others.
- dep is widely accepted as the currently "preferred" solution.

.link https://github.com/moovweb/gvm GitHub.com/moovweb/gvm

.link https://github.com/tools/godep GitHub.com/tools/godep

.link https://github.com/golang/dep GitHub.com/golang/dep

#--
* The Go Team Responded

- Vendor subdirectory.
- Official solution "vgo" coming in August 2018 with Go 1.11. 
- Upgrade path from dep is assured.

.link https://golang.org/cmd/go/#hdr-Vendor_Directories Golang.org/cmd/go/#hdr-Vendor_Directories

.link https://github.com/golang/go/wiki/vgo GitHub.com/golang/go/wiki/vgo



###
* "Garbage collection is expensive."

#--
* Garbage Collection Is Valuable

Memory management:

- eases development and maintenance.
- removes an entire class of security concerns.

Unfortunately:

- GC prevents determinism.

Fortunately:

- most applications don't need determinism (which necessitates complexity).

#--
* Garbage Collection Can Be Avoided 1/2

Allocations Are Caused By:

- Using the new and make built-in funcs (make has a few unlikely exceptions)
- Composite literals when the value type is a slice, map, or a struct with the & operator
- Putting a value larger than a machine word into an interface. (For example, strings, slices, and some structs are larger than a machine word.)
- Converting between string, []byte, and []rune
- As of Go 1.3, the compiler special cases this expression to not allocate: m[string(b)], where m is a map and b is a []byte
- Converting a non-constant integer value to a string
- defer and go statements
- Function literals that capture local variables

.link http://stackoverflow.com/questions/12277426/how-to-minimize-the-garbage-collection-in-go/12290168#12290168 Stackoverflow.com/questions/12277426

#--
* Garbage Collection Can Be Avoided 2/2

Allocations Might Be Caused By:

- Taking the address of a variable. Note that addresses can be taken implicitly. For example a.b() might take the address of a if a isn't a pointer and the b method has a pointer receiver type.
- Using the append built-in function
- Calling a variadic function or method
- Slicing an array
- Adding an element to a map

.link http://stackoverflow.com/questions/12277426/how-to-minimize-the-garbage-collection-in-go/12290168#12290168 Stackoverflow.com/questions/12277426

#--
* Garbage Collection Is Improving Dramatically 1/3

.image img/garbage_1p3x-1p5x.png

.link https://talks.golang.org/2015/go-gc.pdf talks.Golang.org/2015/go-gc.pdf

#--
* Garbage Collection Is Improving Dramatically 2/3

.image img/garbage_1p5x-1p6x.png

.link http://www.infoq.com/presentations/go-gc-performance Infoq.com/presentations/go-gc-performance

#--
* Garbage Collection Is Improving Dramatically 3/3

.image img/garbage_1p6.png

.link https://talks.golang.org/2016/state-of-go.slide#38 talks.Golang.org/2016/state-of-go.slide

#--
* Garbage Collection Will Continue Improving 1/2

"At a higher level, one approach to solving performance problems is to add GC knobs, one for each performance issue. The programmer can then turn the knobs in search of appropriate settings for their application. The downside is that after a decade with one or two new knobs each year you end up with the GC Knobs Turner Employment Act. Go is not going down that path. Instead we provide a single knob, called GOGC. This value controls the total size of the heap relative to the size of reachable objects. The default value of 100 means that total heap size is now 100% bigger than (i.e., twice) the size of the reachable objects after the last collection. 200 means total heap size is 200% bigger than (i.e., three times) the size of the reachable objects. If you want to lower the total time spent in GC, increase GOGC. If you want to trade more GC time for less memory, lower GOGC."

.link https://blog.golang.org/go15gc blog.Golang.org/go15gc

#--
* Garbage Collection Will Continue Improving 2/2

More importantly as RAM doubles with the next generation of hardware, simply doubling GOGC will halve the number of GC cycles. On the other hand since GOGC is based on reachable object size, doubling the load by doubling the reachable objects requires no retuning. The application just scales. Furthermore, unencumbered by ongoing support for dozens of knobs, the runtime team can focus on improving the runtime based on feedback from real customer applications."

.link https://blog.golang.org/go15gc blog.Golang.org/go15gc
